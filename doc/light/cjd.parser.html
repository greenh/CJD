<!DOCTYPE html>
<html><head><meta charset="ISO-8859-1"><title>CJD &ndash; cjd.parser</title><link href="cjd.css" rel="stylesheet" type="text/css" /><link href="extensomatic.css" rel="stylesheet" type="text/css" /></head><body><div id="top"></div><div class="leader"><table><tbody><tr><td width="100%"><td align="right"><a href="index.html"><span class="headlink">Index</span></a></td></tr></tbody></table></div><div><a class="ns" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L16">cjd.parser</a></div><div class="desc"><p>Parser for CJD comments, wherein a CJD-comment in the form of a sequence of Clojure forms is parsed into an abstract syntax tree. The resulting AST then serves as the basis for HTML generation.</p></div><div class="desc"><table class="summary"><tbody><tr><td colspan="2"><p class="sum-hdr">Constructo Summary</p></td></tr><tr class="sum"><td><a href="#Element">Element</a></td><td><div class="blurb">Describes elements for the comment parsing process. </div></td></tr><tr><td colspan="2"><p class="sum-hdr">Function/Macro Summary</p></td></tr><tr class="sum"><td><a href="#flow-run">flow&#8209;run</a></td><td><div class="blurb">Processes a sequence of CJD comment-content forms into a sequence of flow-forms, which will in turn contain phrasing and text content. </div></td></tr><tr class="sum"><td><a href="#mk-el">mk&#8209;el</a></td><td><div class="blurb">Defines a flow element, and adds it to the collection of flow elements recognized by the parser. </div></td></tr><tr class="sum"><td><a href="#mk-ph">mk&#8209;ph</a></td><td><div class="blurb">Makes a phrase element and adds it to the phrase-element map used by the CJD comment parser. </div></td></tr><tr class="sum"><td><a href="#mk-phf">mk&#8209;phf</a></td><td><div class="blurb">Makes a phrase-form with a custom parse function and adds it to the phrase-form-parsed map used by the CJD comment parser. </div></td></tr><tr class="sum"><td><a href="#mk-phx">mk&#8209;phx</a></td><td><div class="blurb">Makes a phrase-form and adds it to the phrase-form map used by the CJD comment parser. </div></td></tr><tr class="sum"><td><a href="#parse-comment">parse&#8209;comment</a></td><td><div class="blurb">Parser for CJD comment content. </div></td></tr><tr class="sum"><td><a href="#phrasing-run">phrasing&#8209;run</a></td><td><div class="blurb">Parses the phrasing content within a flow into a tree of phrasing elements and forms, and text nodes. </div></td></tr><tr class="sum"><td><a href="#text-run">text&#8209;run</a></td><td><div class="blurb">Works through a list of comment text, turning it into a string. </div></td></tr></tbody></table></div><div class="artifact" id="Element"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L173">Element</a></td><td align="right"><a href="http://greenh.github.com/Extensomatic/doc/dark/extensomatic.extensomatic.html#defconstructo">defconstructo</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">Element</span> [<span class="n1">tags</span> <span class="n1">desc</span> <span class="n1">arity</span> <span class="n1">new&#8209;fn</span>])</span></p><div class="desc"><p>Describes elements for the comment parsing process. </p><p>There are several classes of elements; all share the same structure, but are segregated into different maps corresponding to different syntactic entities. Not pretty, but it does allow tags like &quot;arg&quot; to be used for both phrasing and flow forms. </p><div class="s1"><p class="v1"><span class="k1">Fields</span></p><p class="a1"><span class="n1">tags</span> &mdash; A collection of tag strings used to identify the element. </p><p class="a1"><span class="n1">desc</span> &mdash; A Very Short description string (why, we're not sure yet). </p><p class="a1"><span class="n1">arity</span> &mdash; The number of argument forms to acquire. </p><p class="a1"><span class="n1">phrase?</span> &mdash; True if the element accepts a phrase as a final argument. This is only meaningful for phrase-form elements (see <a href="#mk-phx">mk-phx</a>). </p><p class="a1"><span class="n1">new&#8209;fn</span> &mdash; A function that creates an object to represent the parsed element.</p></div><div class="s1"><p class="v1"><span class="k1">Locally implemented methods</span></p><p class="a1"><span class="expr" id="arity-of">(<span class="n0">arity&#8209;of</span> [this])</span></p><p class="a1"><span class="expr" id="new-of">(<span class="n0">new&#8209;of</span> [this])</span></p></div></div></div><div class="artifact" id="flow-run"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L489">flow-run</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">flow&#8209;run</span> [<span class="n1">context</span> <span class="n1">contents</span>])</span></p><div class="desc"><p>Processes a sequence of CJD comment-content forms into a sequence of flow-forms, which will in turn contain phrasing and text content. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">context</span> &mdash; The context map. </p><p class="a1"><span class="n1">contents</span> &mdash; A sequence of input forms to be parsed. </p></div><div><p class="i1"><span class="k1">Returns</span></p><p>A tuple of the form <code>[<span class="n2">flows</span> <span class="n2">remaining</span>]</code>, where </p><div class="s"><p class="a"><span class="n2">flows</span> &mdash; A sequence of flow nodes describing the parsed content </p><p class="a"><span class="n2">remaining</span> &mdash; Any unparsed forms in the input sequence.</p></div></div></div></div><div class="artifact" id="mk-el"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L432">mk-el</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">mk&#8209;el</span> [<span class="n1">tags</span> <span class="n1">desc</span> <span class="n1">arity</span> <span class="n1">new&#8209;fn</span>])</span></p><div class="desc"><p>Defines a flow element, and adds it to the collection of flow elements recognized by the parser. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">tags</span> &mdash; A vector of symbols representing the tags that introduce the element, e.g. <code>['return 'returns 'rv]</code> for the returned values tag. These symbols are all treated as synonyms. </p><p class="a1"><span class="n1">desc</span> &mdash; A string containing a <i>very</i> short description of the element. </p><p class="a1"><span class="n1">arity</span> &mdash; The number of forms following the tag that are to be treated as arguments. May be zero or any positive integer. Any forms following the arguments are treated as content. <code>@arg</code>, for example, takes the name of the argument as a parameter, and thus has an arity of 1.0 </p><p class="a1"><span class="n1">new&#8209;fn</span> &mdash; A function that the parser invokes to generate an object representing the element. The function has a form <code>(<span class="fn">fn</span> [<span class="n2">context</span> <span class="n2">arg...</span> <span class="n2">content</span>])</code>, where </p><div class="s"><p class="a"><span class="n2">context</span> &mdash; The current context object </p><p class="a"><span class="n2">arg...</span> &mdash; Arguments acquired by the parser. The number of these arguments is determined by <span class="n1">arity</span>. </p><p class="a"><span class="n2">content</span> &mdash; The content of the flow element. </p></div><div class="s"><p class="a"><span class="k">Returns</span> &mdash; An object, nominally a derivative of <a href="cjd.core-elements.html#Flow">Flow</a> extenso, that represents the flow element.</p></div></div></div></div><div class="artifact" id="mk-ph"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L194">mk-ph</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">mk&#8209;ph</span> [<span class="n1">tags</span> <span class="n1">desc</span> <span class="n1">new&#8209;fn</span>])</span></p><div class="desc"><p>Makes a phrase element and adds it to the phrase-element map used by the CJD comment parser. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">tags</span> &mdash; A list of tag symbols. These are the symbols that are used with &quot;@&quot; to specify the phrase element, e.g. <code>'b</code> for the <code>@(b ...)</code> phrase element for bold text. </p><p class="a1"><span class="n1">desc</span> &mdash; A string containing a very short description of the phrase element. </p><p class="a1"><span class="n1">new&#8209;fn</span> &mdash; A function that creates an object to represent the phrase element and its contents in the parse tree. It has the form <code>(<span class="fn">fn</span> [<span class="n2">context</span> <span class="n2">content</span>])</code>, where </p><div class="s"><p class="a"><span class="n2">context</span> &mdash; The context map currently in force. </p><p class="a"><span class="n2">content</span> &mdash; The subtree of phrasing content to be contained within the phrasing element. </p></div><div class="s"><p class="a"><span class="k">Returns</span> &mdash; An object representing the phrase element and its content.</p></div></div><div><p class="i1"><span class="k1">Returns</span></p><p>nil.</p></div></div></div><div class="artifact" id="mk-phf"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L282">mk-phf</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">mk&#8209;phf</span> [<span class="n1">tags</span> <span class="n1">desc</span> <span class="n1">parse&#8209;fn</span>])</span></p><div class="desc"><p>Makes a phrase-form with a custom parse function and adds it to the phrase-form-parsed map used by the CJD comment parser. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">tags</span> &mdash; A list of tag symbols. These are the symbols that are used with &quot;@&quot; to specify the phrase form. </p><p class="a1"><span class="n1">desc</span> &mdash; A string containing a very short description of the phrase form. </p><p class="a1"><span class="n1">parse&#8209;fn</span> &mdash; A function that parses the supplied content, and if it's acceptable, and creates and returns an object representing the phrase-form and serving as its node in the comment's AST. This function has the form <code>(<span class="fn">fn</span> [<span class="n2">context</span> <span class="n2">post&#8209;tag</span>])</code>, where </p><div class="s"><p class="a"><span class="n2">context</span> &mdash; The <a href="cjd.context.html#Context">Context</a> object then in force. </p><p class="a"><span class="n2">post&#8209;tag</span> &mdash; A list containing the content of the element that follows the tag. </p></div><div class="s"><p class="a"><span class="k">Returns</span> &mdash; An object representing the phrasing form and its content.</p></div></div><div><p class="i1"><span class="k1">Returns</span></p><p>nil.</p></div></div></div><div class="artifact" id="mk-phx"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L236">mk-phx</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">mk&#8209;phx</span> [<span class="n1">tags</span> <span class="n1">desc</span> <span class="n1">arity</span> <span class="n1">new&#8209;fn</span>])</span></p><div class="desc"><p>Makes a phrase-form and adds it to the phrase-form map used by the CJD comment parser. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">tags</span> &mdash; A list of tag symbols. These are the symbols that are used with &quot;@&quot; to specify the phrase form. </p><p class="a1"><span class="n1">desc</span> &mdash; A string containing a very short description of the phrase form. </p><p class="a1"><span class="n1">arity</span> &mdash; The number of arguments that should follow the tag. If a tag supports multiple arities, use a separate invocation of <span class="n0">mk-phx</span> for each arity. in effect specifying that that the input form has <i>at least</i> the number of arguments given by <span class="n1">arity</span>. </p><p class="a1"><span class="n1">new&#8209;fn</span> &mdash; A function that creates an object representing the phrase-form and serving as its node in the comment's AST. This function has the form <code>(<span class="fn">fn</span> [<span class="n2">context</span> <span class="n2">other&#8209;params...</span>])</code>, where </p><div class="s"><p class="a"><span class="n2">context</span> &mdash; The <a href="cjd.context.html#Context">Context</a> object then in force. </p><p class="a"><span class="n2">other&#8209;params...</span> &mdash; Other, additional parameters as necessary. The number of these parameters must match the value specified for <span class="n1">arity</span>. </p></div><div class="s"><p class="a"><span class="k">Returns</span> &mdash; An object representing the phrasing form and its content.</p></div></div><div><p class="i1"><span class="k1">Returns</span></p><p>nil.</p></div></div></div><div class="artifact" id="parse-comment"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L593">parse-comment</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">parse&#8209;comment</span> [<span class="n1">context</span> <span class="n1">contents</span>])</span></p><div class="desc"><p>Parser for CJD comment content. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">context</span> &mdash; The context map. </p><p class="a1"><span class="n1">contents</span> &mdash; The CJD comment, notionally as delivered from the CJD reader-hack. It must start with the appropriate symbol, <code>cjd!doc</code>, or it will be rejected. </p></div><div><p class="i1"><span class="k1">Returns</span></p><p>A sequence of flow objects representing the AST of the comment.</p></div></div></div><div class="artifact" id="phrasing-run"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L333">phrasing-run</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">phrasing&#8209;run</span> [<span class="n1">context</span> <span class="n1">form&#8209;contents</span>])</span></p><div class="desc"><p>Parses the phrasing content within a flow into a tree of phrasing elements and forms, and text nodes. </p><p>Syntactically, this consists of chunks of &quot;text&quot; interspersed with tagged forms, either open &agrave; la &quot;@name&quot; or closed, like &quot;@(b bold-text)&quot; </p><p><span class="n0">phrasing-run</span> essentially operates by determining what kind of item is next in its list of unprocessed content, and then invoking an appropriate processing function to operate on it. Each processing function does its thing for whatever scope is appropriate (possibly recursively invoking <span class="n0">phrasing-run</span> in the process), and returns whatever html it has generated, along with any unprocessed comment text. <span class="n0">phrasing-run</span> adds the generated HTML to its string, and then continues processing the remaining input. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">form&#8209;contents</span> &mdash; The content of the source comment form to be processed. </p><p class="a1"><span class="n1">context</span> &mdash; The current context map. </p></div><div><p class="i1"><span class="k1">Returns</span></p><p>A tree of <a href="cjd.core-elements.html#Phrase">Phrase</a>, <a href="cjd.core-elements.html#PhraseForm">PhraseForm</a>, and <a href="cjd.core-elements.html#Text">Text</a> objects that collectively describe the phrasing content.</p></div></div></div><div class="artifact" id="text-run"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/greenh/CJD/blob/master/src/clojure/cjd/parser.clj#L75">text-run</a></td><td align="right"><a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/defn">defn</a> in <a href="#top">cjd.parser</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">text&#8209;run</span> [<span class="n1">context</span> <span class="n1">form&#8209;contents</span> <span class="n1">initial</span>])</span></p><div class="desc"><p>Works through a list of comment text, turning it into a string. </p><p>Processing continues for as long as the input is purely text, defined as being devoid of any directives. As soon as <span class="n0">text-run</span> encounters something non-textual, it quits and returns its text and whatever's left over for continued processing. </p><div class="s1"><p class="v1"><span class="k1">Arguments</span></p><p class="a1"><span class="n1">form&#8209;contents</span> &mdash; The content of the source comment form to be processed. </p><p class="a1"><span class="n1">context</span> &mdash; The current context map. </p><p class="a1"><span class="n1">initial</span> &mdash; If true, then this is the initial call to <span class="n0">text-run</span> within a phrasing run. The specific implication of this is that if this is a <i>not</i> the initial call, then the text run should assume that a space is needed for separation between the prior phrasing element and subsequent text (which is subject to normal rules for elimination), vs. the initial case, where no space is desirable. </p></div><div><p class="i1"><span class="k1">Returns</span></p><p>A tuple of the for <code>[<span class="n2">text</span> <span class="n2">unprocessed</span>]</code>, where: </p><div class="s"><p class="a"><span class="n2">text</span> &mdash; The string containing processed text. This is HTML-ized before being returned to the extent of doing the encoding of problematic characters like &lt;, &gt;, and &amp;, so that the returned string is ready-for-use HTML text. </p><p class="a"><span class="n2">unprocessed</span> &mdash; The unprocessed tail of <span class="n1">form-contents</span>.</p></div></div></div></div><div class="trailer"><span class="ending">Generated by <a href="https://github.com/greenh/CJD">CJD</a> 0.1.0 under Clojure 1.4.0  on 17 December 2012 08:59 PST</span></div><div style="margin-top: 1mm; margin-bottom: 4mm; text-align: center; width: 100%;"><span style="font-size: 8pt;">Copyright &copy; 2012 Howard Green. All rights reserved.</span></div></body></html>