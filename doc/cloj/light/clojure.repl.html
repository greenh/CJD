<!DOCTYPE html>
<html><head><meta charset="ISO-8859-1"><title>Clojure 1.4.0 &ndash; clojure.repl</title><link href="cjd.css" rel="stylesheet" type="text/css" /></head><body><div id="top"></div><div class="leader"><table><tbody><tr><td width="100%"><td align="right"><a href="index.html"><span class="headlink">Index</span></a></td></tr></tbody></table></div><div class="ns">clojure.repl</div><div class="desc"><table class="summary"><tbody><tr><td colspan="2"><p class="sum-hdr">Function/Macro Summary</p></td></tr><tr class="sum"><td><a href="#apropos">apropos</a></td><td><pre class="preblurb">Given a regular expression or stringable thing, return a seq of...</pre></td></tr><tr class="sum"><td><a href="#demunge">demunge</a></td><td><pre class="preblurb">Given a string representation of a fn class,...</pre></td></tr><tr class="sum"><td><a href="#dir">dir</a></td><td><pre class="preblurb">Prints a sorted directory of public vars in a namespace</pre></td></tr><tr class="sum"><td><a href="#dir-fn">dir&#8209;fn</a></td><td><pre class="preblurb">Returns a sorted seq of symbols naming public vars in...</pre></td></tr><tr class="sum"><td><a href="#doc">doc</a></td><td><pre class="preblurb">Prints documentation for a var or special form given its name</pre></td></tr><tr class="sum"><td><a href="#find-doc">find&#8209;doc</a></td><td><pre class="preblurb">Prints documentation for any var whose documentation or name...</pre></td></tr><tr class="sum"><td><a href="#pst">pst</a></td><td><pre class="preblurb">Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the...</pre></td></tr><tr class="sum"><td><a href="#root-cause">root&#8209;cause</a></td><td><pre class="preblurb">Returns the initial cause of an exception or error by peeling off all of...</pre></td></tr><tr class="sum"><td><a href="#set-break-handler!">set&#8209;break&#8209;handler!</a></td><td><pre class="preblurb">Register INT signal handler.  After calling this, Ctrl-C will cause...</pre></td></tr><tr class="sum"><td><a href="#source">source</a></td><td><pre class="preblurb">Prints the source code for the given symbol, if it can find it.</pre></td></tr><tr class="sum"><td><a href="#source-fn">source&#8209;fn</a></td><td><pre class="preblurb">Returns a string of the source code for the given symbol, if it can...</pre></td></tr><tr class="sum"><td><a href="#stack-element-str">stack&#8209;element&#8209;str</a></td><td><pre class="preblurb">Returns a (possibly unmunged) string representation of a StackTraceElement</pre></td></tr><tr class="sum"><td><a href="#thread-stopper">thread&#8209;stopper</a></td><td><pre class="preblurb">Returns a function that takes one arg and uses that as an exception message...</pre></td></tr></tbody></table></div><div class="artifact" id="apropos"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L165">apropos</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">apropos</span> [str&#8209;or&#8209;pattern])</span></p><div class="desc"><pre class="doc">Given a regular expression or stringable thing, return a seq of
all definitions in all currently-loaded namespaces that match the
str-or-pattern.</pre></div></div><div class="artifact" id="demunge"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L210">demunge</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">demunge</span> [fn&#8209;name])</span></p><div class="desc"><pre class="doc">Given a string representation of a fn class,
as in a stack trace element, returns a readable version.</pre></div></div><div class="artifact" id="dir"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L183">dir</a></td><td align="right"><a href="clojure.core.html#defmacro">defmacro</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">dir</span> [nsname])</span></p><div class="desc"><pre class="doc">Prints a sorted directory of public vars in a namespace</pre></div></div><div class="artifact" id="dir-fn"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L177">dir-fn</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">dir&#8209;fn</span> [ns])</span></p><div class="desc"><pre class="doc">Returns a sorted seq of symbols naming public vars in
a namespace</pre></div></div><div class="artifact" id="doc"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L120">doc</a></td><td align="right"><a href="clojure.core.html#defmacro">defmacro</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">doc</span> [name])</span></p><div class="desc"><pre class="doc">Prints documentation for a var or special form given its name</pre></div></div><div class="artifact" id="find-doc"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L104">find-doc</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">find&#8209;doc</span> [re&#8209;string&#8209;or&#8209;pattern])</span></p><div class="desc"><pre class="doc">Prints documentation for any var whose documentation or name
 contains a match for re-string-or-pattern</pre></div></div><div class="artifact" id="pst"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L242">pst</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pst</span> [])</span></p><p class="decl"><span class="expr">(<span class="n0">pst</span> [e&#8209;or&#8209;depth])</span></p><p class="decl"><span class="expr">(<span class="n0">pst</span> [e depth])</span></p><div class="desc"><pre class="doc">Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the
most recent repl exception (*e), and a depth of 12.</pre></div></div><div class="artifact" id="root-cause"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L217">root-cause</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">root&#8209;cause</span> [t])</span></p><div class="desc"><pre class="doc">Returns the initial cause of an exception or error by peeling off all of
its wrappers</pre></div></div><div class="artifact" id="set-break-handler!"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L278">set-break-handler!</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">set&#8209;break&#8209;handler!</span> [])</span></p><p class="decl"><span class="expr">(<span class="n0">set&#8209;break&#8209;handler!</span> [f])</span></p><div class="desc"><pre class="doc">Register INT signal handler.  After calling this, Ctrl-C will cause
the given function f to be called with a single argument, the signal.
Uses thread-stopper if no function given.</pre></div></div><div class="artifact" id="source"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L156">source</a></td><td align="right"><a href="clojure.core.html#defmacro">defmacro</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">source</span> [n])</span></p><div class="desc"><pre class="doc">Prints the source code for the given symbol, if it can find it.
This requires that the symbol resolve to a Var defined in a
namespace for which the .clj is in the classpath.

Example: (source filter)</pre></div></div><div class="artifact" id="source-fn"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L134">source-fn</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">source&#8209;fn</span> [x])</span></p><div class="desc"><pre class="doc">Returns a string of the source code for the given symbol, if it can
find it.  This requires that the symbol resolve to a Var defined in
a namespace for which the .clj is in the classpath.  Returns nil if
it can't find the source.  For most REPL usage, 'source' is more
convenient.

Example: (source-fn 'filter)</pre></div></div><div class="artifact" id="stack-element-str"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L230">stack-element-str</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">stack&#8209;element&#8209;str</span> [el])</span></p><div class="desc"><pre class="doc">Returns a (possibly unmunged) string representation of a StackTraceElement</pre></div></div><div class="artifact" id="thread-stopper"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/repl.clj#L272">thread-stopper</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.repl</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">thread&#8209;stopper</span> [])</span></p><p class="decl"><span class="expr">(<span class="n0">thread&#8209;stopper</span> [thread])</span></p><div class="desc"><pre class="doc">Returns a function that takes one arg and uses that as an exception message
to stop the given thread.  Defaults to the current thread</pre></div></div><div class="trailer"><span class="ending">Generated by <a href="https://github.com/greenh/CJD">CJD</a> 0.1.0 under Clojure 1.4.0  on 14 December 2012 20:23 PST</span></div></body></html>