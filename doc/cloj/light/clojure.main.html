<!DOCTYPE html>
<html><head><meta charset="ISO-8859-1"><title>Clojure 1.4.0 &ndash; clojure.main</title><link href="cjd.css" rel="stylesheet" type="text/css" /></head><body><div id="top"></div><div class="leader"><table><tbody><tr><td width="100%"><td align="right"><a href="index.html"><span class="headlink">Index</span></a></td></tr></tbody></table></div><div class="ns">clojure.main</div><div class="desc"><table class="summary"><tbody><tr><td colspan="2"><p class="sum-hdr">Function/Macro Summary</p></td></tr><tr class="sum"><td><a href="#demunge">demunge</a></td><td><pre class="preblurb">Given a string representation of a fn class,...</pre></td></tr><tr class="sum"><td><a href="#load-script">load&#8209;script</a></td><td><pre class="preblurb">Loads Clojure source from a file or resource given its path. Paths...</pre></td></tr><tr class="sum"><td><a href="#main">main</a></td><td><pre class="preblurb">Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]...</pre></td></tr><tr class="sum"><td><a href="#repl">repl</a></td><td><pre class="preblurb">Generic, reusable, read-eval-print loop. By default, reads from *in*,...</pre></td></tr><tr class="sum"><td><a href="#repl-caught">repl&#8209;caught</a></td><td><pre class="preblurb">Default :caught hook for repl</pre></td></tr><tr class="sum"><td><a href="#repl-exception">repl&#8209;exception</a></td><td><pre class="preblurb">Returns the root cause of throwables</pre></td></tr><tr class="sum"><td><a href="#repl-prompt">repl&#8209;prompt</a></td><td><pre class="preblurb">Default :prompt hook for repl</pre></td></tr><tr class="sum"><td><a href="#repl-read">repl&#8209;read</a></td><td><pre class="preblurb">Default :read hook for repl. Reads from *in* which must either be an...</pre></td></tr><tr class="sum"><td><a href="#root-cause">root&#8209;cause</a></td><td><pre class="preblurb">Returns the initial cause of an exception or error by peeling off all of...</pre></td></tr><tr class="sum"><td><a href="#skip-if-eol">skip&#8209;if&#8209;eol</a></td><td><pre class="preblurb">If the next character on stream s is a newline, skips it, otherwise...</pre></td></tr><tr class="sum"><td><a href="#skip-whitespace">skip&#8209;whitespace</a></td><td><pre class="preblurb">Skips whitespace characters on stream s. Returns :line-start, :stream-end,...</pre></td></tr><tr class="sum"><td><a href="#stack-element-str">stack&#8209;element&#8209;str</a></td><td><pre class="preblurb">Returns a (possibly unmunged) string representation of a StackTraceElement</pre></td></tr><tr class="sum"><td><a href="#with-bindings">with&#8209;bindings</a></td><td><pre class="preblurb">Executes body in the context of thread-local bindings for several vars...</pre></td></tr></tbody></table></div><div class="artifact" id="demunge"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L51">demunge</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">demunge</span> [fn&#8209;name])</span></p><div class="desc"><pre class="doc">Given a string representation of a fn class,
as in a stack trace element, returns a readable version.</pre></div></div><div class="artifact" id="load-script"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L276">load-script</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">load&#8209;script</span> [path])</span></p><div class="desc"><pre class="doc">Loads Clojure source from a file or resource given its path. Paths
beginning with @ or @/ are considered relative to classpath.</pre></div></div><div class="artifact" id="main"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L390">main</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">main</span> [&amp; args])</span></p><div class="desc"><pre class="doc">Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]

With no options or args, runs an interactive Read-Eval-Print Loop

init options:
  -i, --init path     Load a file or resource
  -e, --eval string   Evaluate expressions in string; print non-nil values

main options:
  -m, --main ns-name  Call the -main function from a namespace with args
  -r, --repl          Run a repl
  path                Run a script from from a file or resource
  -                   Run a script from standard input
  -h, -?, --help      Print this help message and exit

operation:

  - Establishes thread-local bindings for commonly set!-able vars
  - Enters the user namespace
  - Binds *command-line-args* to a seq of strings containing command line
    args that appear after any main option
  - Runs all init options in order
  - Calls a -main function or runs a repl or script if requested

The init options may be repeated and mixed freely, but must appear before
any main option. The appearance of any eval option before running a repl
suppresses the usual repl greeting message: "Clojure ~(clojure-version)".

Paths may be absolute or relative in the filesystem or relative to
classpath. Classpath-relative paths have prefix of @ or @/</pre></div></div><div class="artifact" id="repl"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L180">repl</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">repl</span> [&amp; options])</span></p><div class="desc"><pre class="doc">Generic, reusable, read-eval-print loop. By default, reads from *in*,
writes to *out*, and prints exception summaries to *err*. If you use the
default :read hook, *in* must either be an instance of
LineNumberingPushbackReader or duplicate its behavior of both supporting
.unread and collapsing CR, LF, and CRLF into a single \newline. Options
are sequential keyword-value pairs. Available options and their defaults:

   - :init, function of no arguments, initialization hook called with
     bindings for set!-able vars in place.
     default: #()

   - :need-prompt, function of no arguments, called before each
     read-eval-print except the first, the user will be prompted if it
     returns true.
     default: (if (instance? LineNumberingPushbackReader *in*)
                #(.atLineStart *in*)
                #(identity true))

   - :prompt, function of no arguments, prompts for more input.
     default: repl-prompt

   - :flush, function of no arguments, flushes output
     default: flush

   - :read, function of two arguments, reads from *in*:
       - returns its first argument to request a fresh prompt
         - depending on need-prompt, this may cause the repl to prompt
           before reading again
       - returns its second argument to request an exit from the repl
       - else returns the next object read from the input stream
     default: repl-read

   - :eval, funtion of one argument, returns the evaluation of its
     argument
     default: eval

   - :print, function of one argument, prints its argument to the output
     default: prn

   - :caught, function of one argument, a throwable, called when
     read, eval, or print throws an exception or error
     default: repl-caught</pre></div></div><div class="artifact" id="repl-caught"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L168">repl-caught</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">repl&#8209;caught</span> [e])</span></p><div class="desc"><pre class="doc">Default :caught hook for repl</pre></div></div><div class="artifact" id="repl-exception"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L163">repl-exception</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">repl&#8209;exception</span> [throwable])</span></p><div class="desc"><pre class="doc">Returns the root cause of throwables</pre></div></div><div class="artifact" id="repl-prompt"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L108">repl-prompt</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">repl&#8209;prompt</span> [])</span></p><div class="desc"><pre class="doc">Default :prompt hook for repl</pre></div></div><div class="artifact" id="repl-read"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L145">repl-read</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">repl&#8209;read</span> [request&#8209;prompt request&#8209;exit])</span></p><div class="desc"><pre class="doc">Default :read hook for repl. Reads from *in* which must either be an
instance of LineNumberingPushbackReader or duplicate its behavior of both
supporting .unread and collapsing all of CR, LF, and CRLF into a single
\newline. repl-read:
  - skips whitespace, then
    - returns request-prompt on start of line, or
    - returns request-exit on end of stream, or
    - reads an object from the input stream, then
      - skips the next input character if it's end of line, then
      - returns the object.</pre></div></div><div class="artifact" id="root-cause"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L58">root-cause</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">root&#8209;cause</span> [t])</span></p><div class="desc"><pre class="doc">Returns the initial cause of an exception or error by peeling off all of
its wrappers</pre></div></div><div class="artifact" id="skip-if-eol"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L113">skip-if-eol</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">skip&#8209;if&#8209;eol</span> [s])</span></p><div class="desc"><pre class="doc">If the next character on stream s is a newline, skips it, otherwise
leaves the stream untouched. Returns :line-start, :stream-end, or :body
to indicate the relative location of the next character on s. The stream
must either be an instance of LineNumberingPushbackReader or duplicate
its behavior of both supporting .unread and collapsing all of CR, LF, and
CRLF to a single \newline.</pre></div></div><div class="artifact" id="skip-whitespace"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L127">skip-whitespace</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">skip&#8209;whitespace</span> [s])</span></p><div class="desc"><pre class="doc">Skips whitespace characters on stream s. Returns :line-start, :stream-end,
or :body to indicate the relative location of the next character on s.
Interprets comma as whitespace and semicolon as comment to end of line.
Does not interpret #! as comment to end of line because only one
character of lookahead is available. The stream must either be an
instance of LineNumberingPushbackReader or duplicate its behavior of both
supporting .unread and collapsing all of CR, LF, and CRLF to a single
\newline.</pre></div></div><div class="artifact" id="stack-element-str"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L71">stack-element-str</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">stack&#8209;element&#8209;str</span> [el])</span></p><div class="desc"><pre class="doc">Returns a (possibly unmunged) string representation of a StackTraceElement</pre></div></div><div class="artifact" id="with-bindings"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L85">with-bindings</a></td><td align="right"><a href="clojure.core.html#defmacro">defmacro</a> in <a href="#top">clojure.main</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">with&#8209;bindings</span> [&amp; body])</span></p><div class="desc"><pre class="doc">Executes body in the context of thread-local bindings for several vars
that often need to be set!: *ns* *warn-on-reflection* *math-context*
*print-meta* *print-length* *print-level* *compile-path*
*command-line-args* *1 *2 *3 *e</pre></div></div><div class="trailer"><span class="ending">Generated by <a href="https://github.com/greenh/CJD">CJD</a> 0.1.0 under Clojure 1.4.0  on 10 December 2012 20:51 PST</span></div><div style="margin-top: 1mm; margin-bottom: 4mm; text-align: center; width: 100%;"><span style="font-size: 8pt;">Copyright &copy; 2012 Howard Green. All rights reserved.</span></div></body></html>