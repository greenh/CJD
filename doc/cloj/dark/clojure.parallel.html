<!DOCTYPE html>
<html><head><meta charset="ISO-8859-1"><title>Clojure 1.4.0 &ndash; clojure.parallel</title><link href="cjd.css" rel="stylesheet" type="text/css" /></head><body><div id="top"></div><div class="leader"><table><tbody><tr><td width="100%"><td align="right"><a href="index.html"><span class="headlink">Index</span></a></td></tr></tbody></table></div><div><a class="ns" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L9">clojure.parallel</a></div><div class="desc"><table class="summary"><tbody><tr><td colspan="2"><p class="sum-hdr">Function/Macro Summary</p></td></tr><tr class="sum"><td><a href="#pany">pany</a></td><td><pre class="preblurb">Returns some (random) element of the coll if it satisfies the bound/filter/map</pre></td></tr><tr class="sum"><td><a href="#par">par</a></td><td><pre class="preblurb">Creates a parallel array from coll. ops, if supplied, perform...</pre></td></tr><tr class="sum"><td><a href="#pdistinct">pdistinct</a></td><td><pre class="preblurb">Returns a parallel array of the distinct elements of coll</pre></td></tr><tr class="sum"><td><a href="#pfilter-dupes">pfilter&#8209;dupes</a></td><td><pre class="preblurb">Returns a vector containing the (realized) elements of coll, ...</pre></td></tr><tr class="sum"><td><a href="#pfilter-nils">pfilter&#8209;nils</a></td><td><pre class="preblurb">Returns a vector containing the non-nil (realized) elements of coll</pre></td></tr><tr class="sum"><td><a href="#pmax">pmax</a></td><td><pre class="preblurb">Returns the maximum element, presuming Comparable elements, unless...</pre></td></tr><tr class="sum"><td><a href="#pmin">pmin</a></td><td><pre class="preblurb">Returns the minimum element, presuming Comparable elements, unless...</pre></td></tr><tr class="sum"><td><a href="#preduce">preduce</a></td><td><pre class="preblurb">Returns the reduction of the realized elements of coll...</pre></td></tr><tr class="sum"><td><a href="#psort">psort</a></td><td><pre class="preblurb">Returns a new vector consisting of the realized items in coll, sorted, ...</pre></td></tr><tr class="sum"><td><a href="#psummary">psummary</a></td><td><pre class="preblurb">Returns a map of summary statistics (min. max, size, min-index, max-index, ...</pre></td></tr><tr class="sum"><td><a href="#pvec">pvec</a></td><td><pre class="preblurb">Returns the realized contents of the parallel array pa as a Clojure vector</pre></td></tr></tbody></table></div><div class="artifact" id="pany"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L138">pany</a></td><td align="right">defn in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pany</span> [coll])</span></p><div class="desc"><pre class="doc">Returns some (random) element of the coll if it satisfies the bound/filter/map</pre></div></div><div class="artifact" id="par"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L73">par</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">par</span> [coll])</span></p><p class="decl"><span class="expr">(<span class="n0">par</span> [coll &amp; ops])</span></p><div class="desc"><pre class="doc">Creates a parallel array from coll. ops, if supplied, perform
on-the-fly filtering or transformations during parallel realization
or calculation. ops form a chain, and bounds must precede filters,
must precede maps. ops must be a set of keyword value pairs of the
following forms:

   :bound [start end] 

Only elements from start (inclusive) to end (exclusive) will be
processed when the array is realized.

   :filter pred 

Filter preds remove elements from processing when the array is realized. pred
must be a function of one argument whose return will be processed
via boolean.

   :filter-index pred2 

pred2 must be a function of two arguments, which will be an element
of the collection and the corresponding index, whose return will be
processed via boolean.

   :filter-with [pred2 coll2] 

pred2 must be a function of two arguments, which will be
corresponding elements of the 2 collections.

   :map f 

Map fns will be used to transform elements when the array is
realized. f must be a function of one argument.

   :map-index f2 

f2 must be a function of two arguments, which will be an element of
the collection and the corresponding index.

   :map-with [f2 coll2]

f2 must be a function of two arguments, which will be corresponding
elements of the 2 collections.</pre></div></div><div class="artifact" id="pdistinct"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L189">pdistinct</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pdistinct</span> [coll])</span></p><div class="desc"><pre class="doc">Returns a parallel array of the distinct elements of coll</pre></div></div><div class="artifact" id="pfilter-dupes"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L209">pfilter-dupes</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pfilter&#8209;dupes</span> [coll])</span></p><div class="desc"><pre class="doc">Returns a vector containing the (realized) elements of coll, 
without any consecutive duplicates</pre></div></div><div class="artifact" id="pfilter-nils"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L204">pfilter-nils</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pfilter&#8209;nils</span> [coll])</span></p><div class="desc"><pre class="doc">Returns a vector containing the non-nil (realized) elements of coll</pre></div></div><div class="artifact" id="pmax"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L143">pmax</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pmax</span> [coll])</span></p><p class="decl"><span class="expr">(<span class="n0">pmax</span> [coll comp])</span></p><div class="desc"><pre class="doc">Returns the maximum element, presuming Comparable elements, unless
a Comparator comp is supplied</pre></div></div><div class="artifact" id="pmin"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L149">pmin</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pmin</span> [coll])</span></p><p class="decl"><span class="expr">(<span class="n0">pmin</span> [coll comp])</span></p><div class="desc"><pre class="doc">Returns the minimum element, presuming Comparable elements, unless
a Comparator comp is supplied</pre></div></div><div class="artifact" id="preduce"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L164">preduce</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">preduce</span> [f base coll])</span></p><div class="desc"><pre class="doc">Returns the reduction of the realized elements of coll
using function f. Note f will not necessarily be called
consecutively, and so must be commutative. Also note that 
(f base an-element) might be performed many times, i.e. base is not
an initial value as with sequential reduce.</pre></div></div><div class="artifact" id="psort"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L198">psort</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">psort</span> [coll])</span></p><p class="decl"><span class="expr">(<span class="n0">psort</span> [coll comp])</span></p><div class="desc"><pre class="doc">Returns a new vector consisting of the realized items in coll, sorted, 
presuming Comparable elements, unless a Comparator comp is supplied</pre></div></div><div class="artifact" id="psummary"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L158">psummary</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">psummary</span> [coll])</span></p><p class="decl"><span class="expr">(<span class="n0">psummary</span> [coll comp])</span></p><div class="desc"><pre class="doc">Returns a map of summary statistics (min. max, size, min-index, max-index, 
presuming Comparable elements, unless a Comparator comp is supplied</pre></div></div><div class="artifact" id="pvec"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/parallel.clj#L185">pvec</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.parallel</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">pvec</span> [pa])</span></p><div class="desc"><pre class="doc">Returns the realized contents of the parallel array pa as a Clojure vector</pre></div></div><div class="trailer"><span class="ending">Generated by <a href="https://github.com/greenh/CJD">CJD</a> 0.1.0 under Clojure 1.4.0  on 17 December 2012 08:59 PST</span></div></body></html>