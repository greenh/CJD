<!DOCTYPE html>
<html><head><meta charset="ISO-8859-1"><title>Clojure 1.4.0 &ndash; clojure.core.reducers</title><link href="cjd.css" rel="stylesheet" type="text/css" /></head><body><div id="top"></div><div class="leader"><table><tbody><tr><td width="100%"><td align="right"><a href="index.html"><span class="headlink">Index</span></a></td></tr></tbody></table></div><div class="ns">clojure.core.reducers</div><div class="desc"><table class="summary"><tbody><tr><td colspan="2"><p class="sum-hdr">Function/Macro Summary</p></td></tr><tr class="sum"><td><a href="#append!">append!</a></td><td><pre class="preblurb">.adds x to acc and returns acc</pre></td></tr><tr class="sum"><td><a href="#cat">cat</a></td><td><pre class="preblurb">A high-performance combining fn that yields the catenation of the...</pre></td></tr><tr class="sum"><td><a href="#compile-if">compile&#8209;if</a></td><td><pre class="preblurb">Evaluate `exp` and if it returns logical true and doesn't error, expand to...</pre></td></tr><tr class="sum"><td><a href="#defcurried">defcurried</a></td><td><pre class="preblurb">Builds another arity of the fn that returns a fn awaiting the last...</pre></td></tr><tr class="sum"><td><a href="#fold">fold</a></td><td><pre class="preblurb">Reduces a collection using a (potentially parallel) reduce-combine...</pre></td></tr><tr class="sum"><td><a href="#foldcat">foldcat</a></td><td><pre class="preblurb">Equivalent to (fold cat append! coll)</pre></td></tr><tr class="sum"><td><a href="#folder">folder</a></td><td><pre class="preblurb">Given a foldable collection, and a transformation function xf,...</pre></td></tr><tr class="sum"><td><a href="#monoid">monoid</a></td><td><pre class="preblurb">Builds a combining fn out of the supplied operator and identity...</pre></td></tr><tr class="sum"><td><a href="#reduce">reduce</a></td><td><pre class="preblurb">Like core/reduce except:...</pre></td></tr><tr class="sum"><td><a href="#reducer">reducer</a></td><td><pre class="preblurb">Given a reducible collection, and a transformation function xf,...</pre></td></tr><tr class="sum"><td><a href="#rfn">rfn</a></td><td><pre class="preblurb">Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.</pre></td></tr></tbody></table></div><div class="artifact" id="append!"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L303">append!</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">append!</span> [acc x])</span></p><div class="desc"><pre class="doc">.adds x to acc and returns acc</pre></div></div><div class="artifact" id="cat"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L283">cat</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">cat</span> [])</span></p><p class="decl"><span class="expr">(<span class="n0">cat</span> [ctor])</span></p><p class="decl"><span class="expr">(<span class="n0">cat</span> [left right])</span></p><div class="desc"><pre class="doc">A high-performance combining fn that yields the catenation of the
reduced values. The result is reducible, foldable, seqable and
counted, providing the identity collections are reducible, seqable
and counted. The single argument version will build a combining fn
with the supplied identity constructor. Tests for identity
with (zero? (count x)). See also foldcat.</pre></div></div><div class="artifact" id="compile-if"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L24">compile-if</a></td><td align="right">defmacro in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">compile&#8209;if</span> [exp then else])</span></p><div class="desc"><pre class="doc">Evaluate `exp` and if it returns logical true and doesn't error, expand to
`then`.  Else expand to `else`.

(compile-if (Class/forName "java.util.concurrent.ForkJoinTask")
  (do-cool-stuff-with-fork-join)
  (fall-back-to-executor-services))</pre></div></div><div class="artifact" id="defcurried"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L139">defcurried</a></td><td align="right">defmacro in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">defcurried</span> [name doc meta args &amp; body])</span></p><div class="desc"><pre class="doc">Builds another arity of the fn that returns a fn awaiting the last
param</pre></div></div><div class="artifact" id="fold"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L84">fold</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">fold</span> [reducef coll])</span></p><p class="decl"><span class="expr">(<span class="n0">fold</span> [combinef reducef coll])</span></p><p class="decl"><span class="expr">(<span class="n0">fold</span> [n combinef reducef coll])</span></p><div class="desc"><pre class="doc">Reduces a collection using a (potentially parallel) reduce-combine
strategy. The collection is partitioned into groups of approximately
n (default 512), each of which is reduced with reducef (with a seed
value obtained by calling (combinef) with no arguments). The results
of these reductions are then reduced with combinef (default
reducef). combinef must be associative, and, when called with no
arguments, (combinef) must produce its identity element. These
operations may be performed in parallel, but the results will
preserve order.</pre></div></div><div class="artifact" id="foldcat"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L309">foldcat</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">foldcat</span> [coll])</span></p><div class="desc"><pre class="doc">Equivalent to (fold cat append! coll)</pre></div></div><div class="artifact" id="folder"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L114">folder</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">folder</span> [coll xf])</span></p><div class="desc"><pre class="doc">Given a foldable collection, and a transformation function xf,
returns a foldable collection, where any supplied reducing
fn will be transformed by xf. xf is a function of reducing fn to
reducing fn.</pre></div></div><div class="artifact" id="monoid"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L315">monoid</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">monoid</span> [op ctor])</span></p><div class="desc"><pre class="doc">Builds a combining fn out of the supplied operator and identity
constructor. op must be associative and ctor called with no args
must return an identity value for it.</pre></div></div><div class="artifact" id="reduce"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L71">reduce</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">reduce</span> [f coll])</span></p><p class="decl"><span class="expr">(<span class="n0">reduce</span> [f init coll])</span></p><div class="desc"><pre class="doc">Like core/reduce except:
   When init is not provided, (f) is used.
   Maps are reduced with reduce-kv</pre></div></div><div class="artifact" id="reducer"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L100">reducer</a></td><td align="right">defn in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">reducer</span> [coll xf])</span></p><div class="desc"><pre class="doc">Given a reducible collection, and a transformation function xf,
returns a reducible collection, where any supplied reducing
fn will be transformed by xf. xf is a function of reducing fn to
reducing fn.</pre></div></div><div class="artifact" id="rfn"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L156">rfn</a></td><td align="right">defmacro in <a href="#top">clojure.core.reducers</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">rfn</span> [[f1 k] fkv])</span></p><div class="desc"><pre class="doc">Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.</pre></div></div><div class="trailer"><span class="ending">Generated by <a href="https://github.com/greenh/CJD">CJD</a> 0.1.0 under Clojure 1.4.0  on 10 December 2012 20:52 PST</span></div><div style="margin-top: 1mm; margin-bottom: 4mm; text-align: center; width: 100%;"><span style="font-size: 8pt;">Copyright &copy; 2012 Howard Green. All rights reserved.</span></div></body></html>