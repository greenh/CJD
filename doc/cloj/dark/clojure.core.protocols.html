<!DOCTYPE html>
<html><head><meta charset="ISO-8859-1"><title>Clojure 1.4.0 &ndash; clojure.core.protocols</title><link href="cjd.css" rel="stylesheet" type="text/css" /></head><body><div id="top"></div><div class="leader"><table><tbody><tr><td width="100%"><td align="right"><a href="index.html"><span class="headlink">Index</span></a></td></tr></tbody></table></div><div class="ns">clojure.core.protocols</div><div class="desc"><table class="summary"><tbody><tr><td colspan="2"><p class="sum-hdr">Protocol Summary</p></td></tr><tr class="sum"><td><a href="#CollReduce">CollReduce</a></td><td><pre class="preblurb">Protocol for collection types that can implement reduce faster than...</pre></td></tr><tr class="sum"><td><a href="#IKVReduce">IKVReduce</a></td><td><pre class="preblurb">Protocol for concrete associative types that can reduce themselves...</pre></td></tr><tr class="sum"><td><a href="#InternalReduce">InternalReduce</a></td><td><pre class="preblurb">Protocol for concrete seq types that can reduce themselves...</pre></td></tr></tbody></table></div><div class="artifact" id="CollReduce"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/protocols.clj#L13">CollReduce</a></td><td align="right"><a href="clojure.core.html#defprotocol">defprotocol</a> in <a href="#top">clojure.core.protocols</a></td></tr></tbody></table><div class="desc"><pre class="doc">Protocol for collection types that can implement reduce faster than
first/next recursion. Called by clojure.core/reduce. Baseline
implementation defined in terms of Iterable.</pre><div class="s1"><p class="v1"><span class="k1">Methods</span></p><div id="coll-reduce"><p class="a1"><span class="expr">(<span class="n0">coll&#8209;reduce</span> [coll f])</span></p></div><p class="a1"><span class="expr">(<span class="n0">coll&#8209;reduce</span> [coll f val])</span></p></div></div></div><div class="artifact" id="IKVReduce"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/protocols.clj#L159">IKVReduce</a></td><td align="right"><a href="clojure.core.html#defprotocol">defprotocol</a> in <a href="#top">clojure.core.protocols</a></td></tr></tbody></table><div class="desc"><pre class="doc">Protocol for concrete associative types that can reduce themselves
 via a function of key and val faster than first/next recursion over map
 entries. Called by clojure.core/reduce-kv, and has same
 semantics (just different arg order).</pre><div class="s1"><p class="v1"><span class="k1">Methods</span></p><div id="kv-reduce"></div><p class="a1"><span class="expr">(<span class="n0">kv&#8209;reduce</span> [amap f init])</span></p></div></div></div><div class="artifact" id="InternalReduce"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/protocols.clj#L19">InternalReduce</a></td><td align="right"><a href="clojure.core.html#defprotocol">defprotocol</a> in <a href="#top">clojure.core.protocols</a></td></tr></tbody></table><div class="desc"><pre class="doc">Protocol for concrete seq types that can reduce themselves
 faster than first/next recursion. Called by clojure.core/reduce.</pre><div class="s1"><p class="v1"><span class="k1">Methods</span></p><div id="internal-reduce"></div><p class="a1"><span class="expr">(<span class="n0">internal&#8209;reduce</span> [seq f start])</span></p></div></div></div><div class="trailer"><span class="ending">Generated by <a href="https://github.com/greenh/CJD">CJD</a> 0.1.0 under Clojure 1.4.0  on 10 December 2012 20:52 PST</span></div><div style="margin-top: 1mm; margin-bottom: 4mm; text-align: center; width: 100%;"><span style="font-size: 8pt;">Copyright &copy; 2012 Howard Green. All rights reserved.</span></div></body></html>