<!DOCTYPE html>
<html><head><meta charset="ISO-8859-1"><title>Clojure 1.4.0 &ndash; clojure.zip</title><link href="cjd.css" rel="stylesheet" type="text/css" /></head><body><div id="top"></div><div class="leader"><table><tbody><tr><td width="100%"><td align="right"><a href="index.html"><span class="headlink">Index</span></a></td></tr></tbody></table></div><div class="ns">clojure.zip</div><div class="desc"><table class="summary"><tbody><tr><td colspan="2"><p class="sum-hdr">Function/Macro Summary</p></td></tr><tr class="sum"><td><a href="#append-child">append&#8209;child</a></td><td><pre class="preblurb">Inserts the item as the rightmost child of the node at this loc,...</pre></td></tr><tr class="sum"><td><a href="#branch?">branch?</a></td><td><pre class="preblurb">Returns true if the node at loc is a branch</pre></td></tr><tr class="sum"><td><a href="#children">children</a></td><td><pre class="preblurb">Returns a seq of the children of node at loc, which must be a branch</pre></td></tr><tr class="sum"><td><a href="#down">down</a></td><td><pre class="preblurb">Returns the loc of the leftmost child of the node at this loc, or...</pre></td></tr><tr class="sum"><td><a href="#edit">edit</a></td><td><pre class="preblurb">Replaces the node at this loc with the value of (f node args)</pre></td></tr><tr class="sum"><td><a href="#end?">end?</a></td><td><pre class="preblurb">Returns true if loc represents the end of a depth-first walk</pre></td></tr><tr class="sum"><td><a href="#insert-child">insert&#8209;child</a></td><td><pre class="preblurb">Inserts the item as the leftmost child of the node at this loc,...</pre></td></tr><tr class="sum"><td><a href="#insert-left">insert&#8209;left</a></td><td><pre class="preblurb">Inserts the item as the left sibling of the node at this loc,...</pre></td></tr><tr class="sum"><td><a href="#insert-right">insert&#8209;right</a></td><td><pre class="preblurb">Inserts the item as the right sibling of the node at this loc,...</pre></td></tr><tr class="sum"><td><a href="#left">left</a></td><td><pre class="preblurb">Returns the loc of the left sibling of the node at this loc, or nil</pre></td></tr><tr class="sum"><td><a href="#leftmost">leftmost</a></td><td><pre class="preblurb">Returns the loc of the leftmost sibling of the node at this loc, or self</pre></td></tr><tr class="sum"><td><a href="#lefts">lefts</a></td><td><pre class="preblurb">Returns a seq of the left siblings of this loc</pre></td></tr><tr class="sum"><td><a href="#make-node">make&#8209;node</a></td><td><pre class="preblurb">Returns a new branch node, given an existing node and new...</pre></td></tr><tr class="sum"><td><a href="#next">next</a></td><td><pre class="preblurb">Moves to the next loc in the hierarchy, depth-first. When reaching...</pre></td></tr><tr class="sum"><td><a href="#node">node</a></td><td><pre class="preblurb">Returns the node at loc</pre></td></tr><tr class="sum"><td><a href="#path">path</a></td><td><pre class="preblurb">Returns a seq of nodes leading to this loc</pre></td></tr><tr class="sum"><td><a href="#prev">prev</a></td><td><pre class="preblurb">Moves to the previous loc in the hierarchy, depth-first. If already...</pre></td></tr><tr class="sum"><td><a href="#remove">remove</a></td><td><pre class="preblurb">Removes the node at loc, returning the loc that would have preceded...</pre></td></tr><tr class="sum"><td><a href="#replace">replace</a></td><td><pre class="preblurb">Replaces the node at this loc, without moving</pre></td></tr><tr class="sum"><td><a href="#right">right</a></td><td><pre class="preblurb">Returns the loc of the right sibling of the node at this loc, or nil</pre></td></tr><tr class="sum"><td><a href="#rightmost">rightmost</a></td><td><pre class="preblurb">Returns the loc of the rightmost sibling of the node at this loc, or self</pre></td></tr><tr class="sum"><td><a href="#rights">rights</a></td><td><pre class="preblurb">Returns a seq of the right siblings of this loc</pre></td></tr><tr class="sum"><td><a href="#root">root</a></td><td><pre class="preblurb">zips all the way up and returns the root node, reflecting any...</pre></td></tr><tr class="sum"><td><a href="#seq-zip">seq&#8209;zip</a></td><td><pre class="preblurb">Returns a zipper for nested sequences, given a root sequence</pre></td></tr><tr class="sum"><td><a href="#up">up</a></td><td><pre class="preblurb">Returns the loc of the parent of the node at this loc, or nil if at...</pre></td></tr><tr class="sum"><td><a href="#vector-zip">vector&#8209;zip</a></td><td><pre class="preblurb">Returns a zipper for nested vectors, given a root vector</pre></td></tr><tr class="sum"><td><a href="#xml-zip">xml&#8209;zip</a></td><td><pre class="preblurb">Returns a zipper for xml elements (as from xml/parse),...</pre></td></tr><tr class="sum"><td><a href="#zipper">zipper</a></td><td><pre class="preblurb">Creates a new zipper structure. </pre></td></tr></tbody></table></div><div class="artifact" id="append-child"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L223">append-child</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">append&#8209;child</span> [loc item])</span></p><div class="desc"><pre class="doc">Inserts the item as the rightmost child of the node at this loc,
without moving</pre></div></div><div class="artifact" id="branch?"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L69">branch?</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">branch?</span> [loc])</span></p><div class="desc"><pre class="doc">Returns true if the node at loc is a branch</pre></div></div><div class="artifact" id="children"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L75">children</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">children</span> [loc])</span></p><div class="desc"><pre class="doc">Returns a seq of the children of node at loc, which must be a branch</pre></div></div><div class="artifact" id="down"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L109">down</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">down</span> [loc])</span></p><div class="desc"><pre class="doc">Returns the loc of the leftmost child of the node at this loc, or
nil if no children</pre></div></div><div class="artifact" id="edit"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L210">edit</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">edit</span> [loc f &amp; args])</span></p><div class="desc"><pre class="doc">Replaces the node at this loc with the value of (f node args)</pre></div></div><div class="artifact" id="end?"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L258">end?</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">end?</span> [loc])</span></p><div class="desc"><pre class="doc">Returns true if loc represents the end of a depth-first walk</pre></div></div><div class="artifact" id="insert-child"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L216">insert-child</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">insert&#8209;child</span> [loc item])</span></p><div class="desc"><pre class="doc">Inserts the item as the leftmost child of the node at this loc,
without moving</pre></div></div><div class="artifact" id="insert-left"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L183">insert-left</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">insert&#8209;left</span> [loc item])</span></p><div class="desc"><pre class="doc">Inserts the item as the left sibling of the node at this loc,
 without moving</pre></div></div><div class="artifact" id="insert-right"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L193">insert-right</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">insert&#8209;right</span> [loc item])</span></p><div class="desc"><pre class="doc">Inserts the item as the right sibling of the node at this loc,
without moving</pre></div></div><div class="artifact" id="left"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L166">left</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">left</span> [loc])</span></p><div class="desc"><pre class="doc">Returns the loc of the left sibling of the node at this loc, or nil</pre></div></div><div class="artifact" id="leftmost"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L174">leftmost</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">leftmost</span> [loc])</span></p><div class="desc"><pre class="doc">Returns the loc of the leftmost sibling of the node at this loc, or self</pre></div></div><div class="artifact" id="lefts"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L96">lefts</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">lefts</span> [loc])</span></p><div class="desc"><pre class="doc">Returns a seq of the left siblings of this loc</pre></div></div><div class="artifact" id="make-node"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L83">make-node</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">make&#8209;node</span> [loc node children])</span></p><div class="desc"><pre class="doc">Returns a new branch node, given an existing node and new
children. The loc is only used to supply the constructor.</pre></div></div><div class="artifact" id="next"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L230">next</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">next</span> [loc])</span></p><div class="desc"><pre class="doc">Moves to the next loc in the hierarchy, depth-first. When reaching
the end, returns a distinguished loc detectable via end?. If already
at the end, stays there.</pre></div></div><div class="artifact" id="node"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L64">node</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">node</span> [loc])</span></p><div class="desc"><pre class="doc">Returns the node at loc</pre></div></div><div class="artifact" id="path"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L90">path</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">path</span> [loc])</span></p><div class="desc"><pre class="doc">Returns a seq of nodes leading to this loc</pre></div></div><div class="artifact" id="prev"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L246">prev</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">prev</span> [loc])</span></p><div class="desc"><pre class="doc">Moves to the previous loc in the hierarchy, depth-first. If already
at the root, returns nil.</pre></div></div><div class="artifact" id="remove"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L264">remove</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">remove</span> [loc])</span></p><div class="desc"><pre class="doc">Removes the node at loc, returning the loc that would have preceded
it in a depth-first walk.</pre></div></div><div class="artifact" id="replace"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L203">replace</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">replace</span> [loc node])</span></p><div class="desc"><pre class="doc">Replaces the node at this loc, without moving</pre></div></div><div class="artifact" id="right"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L149">right</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">right</span> [loc])</span></p><div class="desc"><pre class="doc">Returns the loc of the right sibling of the node at this loc, or nil</pre></div></div><div class="artifact" id="rightmost"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L157">rightmost</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">rightmost</span> [loc])</span></p><div class="desc"><pre class="doc">Returns the loc of the rightmost sibling of the node at this loc, or self</pre></div></div><div class="artifact" id="rights"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L102">rights</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">rights</span> [loc])</span></p><div class="desc"><pre class="doc">Returns a seq of the right siblings of this loc</pre></div></div><div class="artifact" id="root"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L137">root</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">root</span> [loc])</span></p><div class="desc"><pre class="doc">zips all the way up and returns the root node, reflecting any
 changes.</pre></div></div><div class="artifact" id="seq-zip"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L35">seq-zip</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">seq&#8209;zip</span> [root])</span></p><div class="desc"><pre class="doc">Returns a zipper for nested sequences, given a root sequence</pre></div></div><div class="artifact" id="up"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L123">up</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">up</span> [loc])</span></p><div class="desc"><pre class="doc">Returns the loc of the parent of the node at this loc, or nil if at
the top</pre></div></div><div class="artifact" id="vector-zip"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L44">vector-zip</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">vector&#8209;zip</span> [root])</span></p><div class="desc"><pre class="doc">Returns a zipper for nested vectors, given a root vector</pre></div></div><div class="artifact" id="xml-zip"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L53">xml-zip</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">xml&#8209;zip</span> [root])</span></p><div class="desc"><pre class="doc">Returns a zipper for xml elements (as from xml/parse),
given a root element</pre></div></div><div class="artifact" id="zipper"><table class="topline"><tbody><tr><td><a class="itemname" href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj#L18">zipper</a></td><td align="right"><a href="clojure.core.html#defn">defn</a> in <a href="#top">clojure.zip</a></td></tr></tbody></table><p class="decl"><span class="expr">(<span class="n0">zipper</span> [branch? children make&#8209;node root])</span></p><div class="desc"><pre class="doc">Creates a new zipper structure. 

branch? is a fn that, given a node, returns true if can have
children, even if it currently doesn't.

children is a fn that, given a branch node, returns a seq of its
children.

make-node is a fn that, given an existing node and a seq of
children, returns a new branch node with the supplied children.
root is the root node.</pre></div></div><div class="trailer"><span class="ending">Generated by <a href="https://github.com/greenh/CJD">CJD</a> 0.1.0 under Clojure 1.4.0  on 10 December 2012 20:52 PST</span></div><div style="margin-top: 1mm; margin-bottom: 4mm; text-align: center; width: 100%;"><span style="font-size: 8pt;">Copyright &copy; 2012 Howard Green. All rights reserved.</span></div></body></html>